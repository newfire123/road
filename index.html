<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Cross Road</title>
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <canvas id="game" width="960" height="540"></canvas>
    <script>
var CrossRoad = (() => {
  // src/level-gen.js
  function generateLevel(level) {
    const clamped = Math.max(1, Math.min(level, 9));
    const laneCount = 3 + clamped;
    const baseSpeed = 60 + clamped * 12;
    const lanes = Array.from({ length: laneCount }, (_, i) => ({
      index: i,
      direction: i % 2 === 0 ? 1 : -1,
      speed: baseSpeed + i * 6,
      vehicleCount: 2 + Math.floor(clamped / 2)
    }));
    return {
      level: clamped,
      lanes,
      groundMonsterCount: Math.floor(clamped / 2),
      airMonsterCount: Math.max(1, Math.ceil(clamped / 2)),
      staminaRegenPerSec: 10,
      flyDrainPerSec: 20,
      dashDrainPerSec: 25,
      variableSpeedChance: Math.min(0.6, 0.15 + clamped * 0.05),
      vehicleLengthRange: [0.7, 1.3],
      coinCount: 15,
      coinTarget: 9,
      coinSpread: 0.2 + clamped * 0.06,
      reverseChance: Math.min(0.2, 0.1 + clamped * 0.01),
      vehicleCountPerLane: Math.min(8, 5 + Math.floor(clamped / 3))
    };
  }

  // src/player.js
  function createPlayer(level = 1) {
    const baseMax = 100;
    const maxStamina = baseMax + level * 8;
    return {
      x: 0,
      y: 0,
      speed: 160,
      dashSpeed: 320,
      dashDuration: 0.18,
      dashTimeRemaining: 0,
      dashVector: { x: 0, y: 0 },
      stamina: maxStamina,
      maxStamina,
      isFlying: false,
      w: 18,
      h: 18
    };
  }
  function updateStamina(player, dt, rates) {
    const isDraining = player.isFlying || player.dashTimeRemaining > 0;
    if (isDraining) {
      const drain = player.isFlying ? rates.flyDrainPerSec : rates.dashDrainPerSec;
      player.stamina = Math.max(0, player.stamina - drain * dt);
    } else {
      player.stamina = Math.min(player.maxStamina, player.stamina + rates.regenPerSec * dt);
    }
  }
  function toggleFlight(player, wantsToggle) {
    if (!wantsToggle) return;
    if (player.isFlying) {
      player.isFlying = false;
      return;
    }
    if (player.stamina > 0) {
      player.isFlying = true;
    }
  }
  function tryStartDash(player, inputVector2) {
    if (player.isFlying) return;
    if (player.dashTimeRemaining > 0) return;
    if (player.stamina <= 0) return;
    if (inputVector2.x === 0 && inputVector2.y === 0) return;
    player.dashVector = { x: inputVector2.x, y: inputVector2.y };
    player.dashTimeRemaining = player.dashDuration;
  }
  function updateDash(player, dt) {
    player.dashTimeRemaining = Math.max(0, player.dashTimeRemaining - dt);
  }

  // src/input.js
  function inputVector(keys2) {
    let x = 0;
    let y = 0;
    if (keys2.ArrowLeft) x -= 1;
    if (keys2.ArrowRight) x += 1;
    if (keys2.ArrowUp) y -= 1;
    if (keys2.ArrowDown) y += 1;
    const len = Math.hypot(x, y) || 1;
    return { x: x / len, y: y / len };
  }

  // src/entities.js
  function updateVehicle(vehicle, dt, width) {
    maybeReverseVehicle(vehicle, dt, vehicle.reverseChance ?? 0);
    if (vehicle.variable) {
      vehicle.phaseTime += dt;
      const duration = vehicle.phase === "fast" ? vehicle.fastDuration : vehicle.slowDuration;
      if (vehicle.phaseTime >= duration) {
        vehicle.phaseTime = 0;
        vehicle.phase = vehicle.phase === "fast" ? "slow" : "fast";
      }
      vehicle.speed = vehicle.phase === "fast" ? vehicle.fastSpeed : vehicle.slowSpeed;
    }
    vehicle.x += vehicle.speed * vehicle.dir * dt;
    if (vehicle.dir === 1 && vehicle.x > width) {
      vehicle.x = -vehicle.w;
    }
    if (vehicle.dir === -1 && vehicle.x + vehicle.w < 0) {
      vehicle.x = width;
    }
  }
  function maybeReverseVehicle(vehicle, dt, chance) {
    vehicle.reverseCooldown = Math.max(0, (vehicle.reverseCooldown ?? 0) - dt);
    if (vehicle.reverseCooldown > 0) return;
    if (Math.random() < chance) {
      vehicle.dir *= -1;
      vehicle.reverseCooldown = 3 + Math.random() * 2;
    }
  }

  // src/collision.js
  function aabbIntersects(a, b) {
    return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
  }

  // src/coins.js
  function shouldCollectCoin(player, coin) {
    if (player.isFlying) return false;
    const box = { x: coin.x - coin.r, y: coin.y - coin.r, w: coin.r * 2, h: coin.r * 2 };
    return aabbIntersects(player, box);
  }
  function collectCoin(current, target, coin, canCollect) {
    if (!canCollect) return current;
    if (coin.collected) return current;
    if (current >= target) return current;
    coin.collected = true;
    return current + 1;
  }

  // src/renderer.js
  function clearScreen(ctx2, width, height) {
    ctx2.clearRect(0, 0, width, height);
  }
  function drawPixelRect(ctx2, x, y, w, h, color) {
    ctx2.fillStyle = color;
    ctx2.fillRect(Math.round(x), Math.round(y), Math.round(w), Math.round(h));
  }
  function drawText(ctx2, text, x, y, size, color, align = "center") {
    ctx2.fillStyle = color;
    ctx2.font = `${size}px "Courier New", Courier, monospace`;
    ctx2.textAlign = align;
    ctx2.textBaseline = "middle";
    ctx2.fillText(text, x, y);
  }
  function drawStaminaBar(ctx2, x, y, width, height, ratio) {
    drawPixelRect(ctx2, x, y, width, height, "#1b1f2a");
    drawPixelRect(ctx2, x + 2, y + 2, (width - 4) * ratio, height - 4, "#4ce1b6");
    ctx2.strokeStyle = "#2f3545";
    ctx2.strokeRect(x, y, width, height);
  }
  function drawDashBar(ctx2, x, y, width, height, ratio) {
    drawPixelRect(ctx2, x, y, width, height, "#1b1f2a");
    drawPixelRect(ctx2, x + 2, y + 2, (width - 4) * ratio, height - 4, "#f2a65a");
    ctx2.strokeStyle = "#2f3545";
    ctx2.strokeRect(x, y, width, height);
  }
  function drawCoin(ctx2, x, y, r) {
    drawPixelRect(ctx2, x - r, y - r, r * 2, r * 2, "#f5d34b");
    drawPixelRect(ctx2, x - r + 2, y - r + 2, r * 2 - 4, r * 2 - 4, "#e2b93f");
    drawPixelRect(ctx2, x - 1, y - 1, 2, 2, "#fff2a6");
  }

  // src/game.js
  var SAFE_ZONE_HEIGHT = 60;
  var AIR_MONSTER_SIZE = 16;
  var GROUND_MONSTER_SIZE = 18;
  var VEHICLE_HEIGHT_RATIO = 0.6;
  var DASH_BAR_WIDTH = 90;
  var DASH_BAR_HEIGHT = 8;
  var COIN_RADIUS = 6;
  function randomBetween(min, max) {
    return min + Math.random() * (max - min);
  }
  var Game = class {
    constructor(canvas2, ctx2) {
      this.canvas = canvas2;
      this.ctx = ctx2;
      this.width = canvas2.width;
      this.height = canvas2.height;
      this.state = "title";
      this.levelIndex = 1;
      this.keys = {};
      this.lastKeys = {};
      this.player = null;
      this.level = null;
      this.vehicles = [];
      this.groundMonsters = [];
      this.airMonsters = [];
      this.coins = [];
      this.coinsCollected = 0;
    }
    setKeys(keys2) {
      this.keys = keys2;
    }
    wasPressed(code) {
      return Boolean(this.keys[code]) && !this.lastKeys[code];
    }
    syncKeys() {
      this.lastKeys = { ...this.keys };
    }
    startLevel(levelIndex) {
      this.levelIndex = levelIndex;
      this.level = generateLevel(levelIndex);
      this.player = createPlayer(levelIndex);
      this.player.x = this.width / 2 - this.player.w / 2;
      this.player.y = this.height - SAFE_ZONE_HEIGHT / 2 - this.player.h / 2;
      this.vehicles = this.buildVehicles();
      this.groundMonsters = this.buildGroundMonsters();
      this.airMonsters = this.buildAirMonsters();
      this.coins = this.buildCoins();
      this.coinsCollected = 0;
    }
    buildVehicles() {
      const roadTop = SAFE_ZONE_HEIGHT;
      const roadBottom = this.height - SAFE_ZONE_HEIGHT;
      const roadHeight = roadBottom - roadTop;
      const laneHeight = roadHeight / this.level.lanes.length;
      return this.level.lanes.flatMap((lane, i) => {
        const y = roadTop + i * laneHeight + laneHeight * (1 - VEHICLE_HEIGHT_RATIO) / 2;
        const vehicleCount = Math.min(8, this.level.vehicleCountPerLane + i % 2);
        return Array.from({ length: vehicleCount }, (_, v) => {
          const [minLen, maxLen] = this.level.vehicleLengthRange;
          const lengthScale = randomBetween(minLen, maxLen);
          const w = 42 * lengthScale;
          const h = laneHeight * VEHICLE_HEIGHT_RATIO;
          const x = v * (this.width / vehicleCount) % this.width;
          const isVariable = Math.random() < this.level.variableSpeedChance;
          const fastSpeed = lane.speed * 1.35;
          const slowSpeed = lane.speed * 0.75;
          return {
            x,
            y,
            w,
            h,
            dir: lane.direction,
            speed: lane.speed,
            variable: isVariable,
            fastSpeed,
            slowSpeed,
            fastDuration: 1.5,
            slowDuration: 1.5,
            phase: "fast",
            phaseTime: Math.random() * 1.5,
            reverseChance: this.level.reverseChance,
            reverseCooldown: 1 + Math.random() * 2,
            color: lane.direction === 1 ? "#f8575d" : "#4bc0ff"
          };
        });
      });
    }
    buildCoins() {
      const roadTop = SAFE_ZONE_HEIGHT;
      const roadBottom = this.height - SAFE_ZONE_HEIGHT;
      const padding = 14;
      const minDist = 18 + this.level.coinSpread * 24;
      const coins = [];
      let attempts = 0;
      while (coins.length < this.level.coinCount && attempts < this.level.coinCount * 30) {
        attempts += 1;
        const x = randomBetween(padding, this.width - padding);
        const y = randomBetween(roadTop + padding, roadBottom - padding);
        const tooClose = coins.some((c) => Math.hypot(c.x - x, c.y - y) < minDist);
        if (tooClose) continue;
        coins.push({ x, y, r: COIN_RADIUS, collected: false });
      }
      while (coins.length < this.level.coinCount) {
        coins.push({
          x: randomBetween(padding, this.width - padding),
          y: randomBetween(roadTop + padding, roadBottom - padding),
          r: COIN_RADIUS,
          collected: false
        });
      }
      return coins;
    }
    buildGroundMonsters() {
      const roadTop = SAFE_ZONE_HEIGHT;
      const roadBottom = this.height - SAFE_ZONE_HEIGHT;
      const spacing = (roadBottom - roadTop) / (this.level.groundMonsterCount + 1);
      return Array.from({ length: this.level.groundMonsterCount }, (_, i) => {
        const y = roadTop + spacing * (i + 1) - GROUND_MONSTER_SIZE / 2;
        return {
          x: 40 + i % 2 * (this.width - 80),
          y,
          w: GROUND_MONSTER_SIZE,
          h: GROUND_MONSTER_SIZE,
          minX: 40,
          maxX: this.width - 40 - GROUND_MONSTER_SIZE,
          speed: 40 + i * 6,
          dir: i % 2 === 0 ? 1 : -1
        };
      });
    }
    buildAirMonsters() {
      return Array.from({ length: this.level.airMonsterCount }, (_, i) => ({
        x: this.width - 80 - i * 20,
        y: 30 + i * 20,
        w: AIR_MONSTER_SIZE,
        h: AIR_MONSTER_SIZE,
        speed: 80 + i * 10,
        active: false
      }));
    }
    update(dt) {
      const pressedEnter = this.wasPressed("Enter");
      const pressedDash = this.wasPressed("KeyD");
      const pressedFlight = this.wasPressed("KeyF");
      if (this.state === "title") {
        if (pressedEnter) {
          this.startLevel(1);
          this.state = "play";
        }
        this.syncKeys();
        return;
      }
      if (this.state === "win") {
        if (pressedEnter) {
          if (this.levelIndex >= 9) {
            this.state = "complete";
          } else {
            this.startLevel(this.levelIndex + 1);
            this.state = "play";
          }
        }
        this.syncKeys();
        return;
      }
      if (this.state === "complete") {
        if (pressedEnter) {
          this.state = "title";
        }
        this.syncKeys();
        return;
      }
      if (this.state === "fail") {
        if (pressedEnter) {
          this.startLevel(this.levelIndex);
          this.state = "play";
        }
        this.syncKeys();
        return;
      }
      if (this.state !== "play") {
        this.syncKeys();
        return;
      }
      const move = inputVector(this.keys);
      if (pressedDash) {
        tryStartDash(this.player, move);
      }
      toggleFlight(this.player, pressedFlight);
      updateDash(this.player, dt);
      updateStamina(this.player, dt, {
        flyDrainPerSec: this.level.flyDrainPerSec,
        dashDrainPerSec: this.level.dashDrainPerSec,
        regenPerSec: this.level.staminaRegenPerSec
      });
      if (this.player.stamina <= 0) {
        this.player.isFlying = false;
        if (this.player.dashTimeRemaining > 0) {
          this.player.dashTimeRemaining = 0;
        }
      }
      if (this.player.dashTimeRemaining > 0) {
        this.player.x += this.player.dashVector.x * this.player.dashSpeed * dt;
        this.player.y += this.player.dashVector.y * this.player.dashSpeed * dt;
      } else {
        this.player.x += move.x * this.player.speed * dt;
        this.player.y += move.y * this.player.speed * dt;
      }
      this.player.x = Math.max(0, Math.min(this.player.x, this.width - this.player.w));
      this.player.y = Math.max(0, Math.min(this.player.y, this.height - this.player.h));
      for (const vehicle of this.vehicles) {
        updateVehicle(vehicle, dt, this.width);
      }
      for (const monster of this.groundMonsters) {
        monster.x += monster.speed * monster.dir * dt;
        if (monster.x <= monster.minX || monster.x >= monster.maxX) {
          monster.dir *= -1;
        }
      }
      for (const monster of this.airMonsters) {
        monster.active = this.player.isFlying;
        if (!monster.active) continue;
        const dx = this.player.x - monster.x;
        const dy = this.player.y - monster.y;
        const len = Math.hypot(dx, dy) || 1;
        monster.x += dx / len * monster.speed * dt;
        monster.y += dy / len * monster.speed * dt;
      }
      const playerBox = { x: this.player.x, y: this.player.y, w: this.player.w, h: this.player.h };
      if (!this.player.isFlying) {
        if (this.vehicles.some((v) => aabbIntersects(playerBox, v))) {
          this.state = "fail";
          return;
        }
        if (this.groundMonsters.some((m) => aabbIntersects(playerBox, m))) {
          this.state = "fail";
          return;
        }
      }
      if (this.airMonsters.some((m) => m.active && aabbIntersects(playerBox, m))) {
        this.state = "fail";
        return;
      }
      for (const coin of this.coins) {
        if (coin.collected) continue;
        const canCollect = shouldCollectCoin(this.player, coin);
        this.coinsCollected = collectCoin(this.coinsCollected, this.level.coinTarget, coin, canCollect);
      }
      const roadTop = SAFE_ZONE_HEIGHT;
      if (this.player.y <= roadTop - this.player.h / 2 && this.coinsCollected >= this.level.coinTarget) {
        this.state = "win";
      }
      this.syncKeys();
    }
    render() {
      clearScreen(this.ctx, this.width, this.height);
      if (this.state === "title") {
        this.renderTitle();
        return;
      }
      this.renderWorld();
      if (this.state === "fail") {
        this.renderOverlay("\u5931\u8D25", "\u6309 Enter \u91CD\u6765");
        return;
      }
      if (this.state === "win") {
        this.renderOverlay("\u8FC7\u5173", "\u6309 Enter \u7EE7\u7EED");
        return;
      }
      if (this.state === "complete") {
        this.renderOverlay("\u901A\u5173\u5B8C\u6210", "\u6309 Enter \u56DE\u5230\u6807\u9898");
      }
    }
    renderTitle() {
      const cx = this.width / 2;
      const cy = this.height / 2;
      drawText(this.ctx, "Cross Road", cx, cy - 40, 42, "#f5f5f5");
      drawText(this.ctx, "\u6309 Enter \u5F00\u59CB", cx, cy + 20, 18, "#9aa0af");
    }
    renderOverlay(title, subtitle) {
      drawPixelRect(this.ctx, 0, 0, this.width, this.height, "rgba(0,0,0,0.45)");
      drawText(this.ctx, title, this.width / 2, this.height / 2 - 10, 36, "#f5f5f5");
      drawText(this.ctx, subtitle, this.width / 2, this.height / 2 + 26, 16, "#9aa0af");
    }
    renderWorld() {
      const roadTop = SAFE_ZONE_HEIGHT;
      const roadBottom = this.height - SAFE_ZONE_HEIGHT;
      drawPixelRect(this.ctx, 0, 0, this.width, roadTop, "#1a2a1f");
      drawPixelRect(this.ctx, 0, roadTop, this.width, roadBottom - roadTop, "#2a2e3a");
      drawPixelRect(this.ctx, 0, roadBottom, this.width, SAFE_ZONE_HEIGHT, "#1a2a1f");
      const laneHeight = (roadBottom - roadTop) / this.level.lanes.length;
      for (let i = 1; i < this.level.lanes.length; i += 1) {
        const y = roadTop + i * laneHeight;
        drawPixelRect(this.ctx, 0, y, this.width, 2, "#3a3f4c");
      }
      for (const vehicle of this.vehicles) {
        const bodyColor = vehicle.variable ? vehicle.phase === "fast" ? "#ff8c61" : vehicle.color : vehicle.color;
        drawPixelRect(this.ctx, vehicle.x, vehicle.y, vehicle.w, vehicle.h, bodyColor);
        drawPixelRect(this.ctx, vehicle.x + 4, vehicle.y + 4, 6, 6, "#ffe57a");
      }
      for (const monster of this.groundMonsters) {
        drawPixelRect(this.ctx, monster.x, monster.y, monster.w, monster.h, "#2cc38a");
        drawPixelRect(this.ctx, monster.x + 4, monster.y + 4, 4, 4, "#0a5b3b");
      }
      drawPixelRect(this.ctx, this.player.x, this.player.y, this.player.w, this.player.h, "#f5d34b");
      if (this.player.isFlying) {
        drawPixelRect(this.ctx, this.player.x + 4, this.player.y + this.player.h, 8, 6, "#ff8c42");
      }
      for (const monster of this.airMonsters) {
        if (!monster.active) continue;
        drawPixelRect(this.ctx, monster.x, monster.y, monster.w, monster.h, "#4d7cff");
        drawPixelRect(this.ctx, monster.x + 2, monster.y + 2, 4, 4, "#a4c2ff");
      }
      for (const coin of this.coins) {
        if (coin.collected) continue;
        drawCoin(this.ctx, coin.x, coin.y, coin.r);
      }
      const staminaRatio = this.player.stamina / this.player.maxStamina;
      drawStaminaBar(this.ctx, 20, 16, 140, 16, staminaRatio);
      if (this.player.dashTimeRemaining > 0) {
        const dashRatio = this.player.dashTimeRemaining / this.player.dashDuration;
        drawDashBar(this.ctx, 20, 36, DASH_BAR_WIDTH, DASH_BAR_HEIGHT, dashRatio);
      }
      drawText(this.ctx, `\u5173\u5361 ${this.levelIndex}/9`, this.width - 80, 22, 14, "#c7ccd8", "right");
      drawText(this.ctx, `\u91D1\u5E01 ${this.coinsCollected}/${this.level.coinTarget}`, this.width - 80, 40, 12, "#f2d45c", "right");
      drawText(this.ctx, "\u65B9\u5411\u952E\u79FB\u52A8 | D\u51B2\u523A | F\u98DE\u884C", this.width / 2, this.height - 18, 12, "#9aa0af");
    }
  };

  // src/main.js
  var canvas = document.getElementById("game");
  var ctx = canvas.getContext("2d");
  var game = new Game(canvas, ctx);
  var keys = {};
  window.addEventListener("keydown", (event) => {
    keys[event.code] = true;
  });
  window.addEventListener("keyup", (event) => {
    keys[event.code] = false;
  });
  var last = performance.now();
  function loop(now) {
    const dt = Math.min((now - last) / 1e3, 0.05);
    last = now;
    game.setKeys(keys);
    game.update(dt);
    game.render();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
})();

</script>
  </body>
</html>
